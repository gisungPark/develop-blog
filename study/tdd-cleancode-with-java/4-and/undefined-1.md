# 레거시 코드 리팩터링

## 2023년. 개발자에게 가장 필요한 역랑은?

움직이는 자동차의 바뀌를 갈아뀔 수 있는 역량 => 유지보수 역량

실제 동작하는 서비스의 기능을 추가하거나, 변경하는 역량

SI 개발자와 서비스 개발자의 가장 큰 차이점은 유지보수 역량이다.

## 왜 유지보수 역량인가?

이 모든 회사들이 개발자에게 요구하는 역량이 서비스 개발 마인드를 가진 개발자

서비스 개발 마인드의 핵심은 협업 역량 + 유지보수 역량(리팩터링 역량)

레거시 코드가 있는 상태에서 새로운 기능을 추가하고, 개선하는 것이 몇배는 더 어렵다.

## 다시 만들 것인가? 리팩터링할 것인가?

### 빅뱅 전략의 문제점은?

* 부채를 갚아 나가기 위해 시작한 접근 방법. 하지만 새로운 시스템으로 오픈하는 시점은 비슷한 수준의 부채를 떠 안고 시작하는 경우가 대부분이었다.
* 개발자들이 새롭게 만들는 것은 잘하지만 기존 기능을 리팩터링하는 역량을 쌓지 못하므로 새로운 시스템 또한 시간이 지나면 부채는 금방 늘어나게 된다.
* 빅뱅으로 서비스를 새롭게 만드는 기간 동안 비지니스의 새로운 요구를 제한적으로 수용해야 하기 때문에 비지니스의 위험 요소가 된다.

### 점진적으로 리팩터링하는 전략

* 움직이는 자동차 바뀌를 갈아뀌는 것은 힘드록, 지루한 작업의 연속이다.
* 초반에는 상당히 느리고, 답답하다.

### 점진적인 리팩터링 전략의 장점은?

* 비즈니스의 새로운 요구를 수용하면서 점진적으로 리팩터링 할 수 있다.
* 개발자들이 리팩터링 역량을 쌓을 수 있고, **리팩터링에 대한 필요성을 느끼 가능성이 높아지기 때문에 부채를 만들 가능성이 낮아진다.**

## 스트랭글러 패턴을 통한 해결

![](<../../../.gitbook/assets/image (9).png>)

* 스트랭글러(교살자 패턴) - 마틴 파울러

특정 기능을 새로운 애플리케이션 및 서비스롤 점진적으로 교체하여 레거시 시스템을 단계적으로 마이그레이션합니다. 레거시 시스템의 기능이 교체되면 결국 새 시스템이 기존 시스템의 모든 기능을 대체하여 기존 시스템을 중단하고 서비스 해제할 수 있습니다.

## 예제를 통한 점진적인 리팩토링

테스트하기 어려운 코드를 테스트하기 쉬운 코드로 만들기 위해서 AS-IS와 TO-BE 메서드가 공존하면서 리팩토링.

점진적인 리팩토링 핵심은 AS-IS와 TO-BE 메서드가 공존해야 한다.

<figure><img src="../../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

### 인스턴스 생성을 생성자 -> 메서드로 리팩토링

Immutable Object(불변 객체)가 좋은 것은 알겠는데

인스턴스가 너무 많이 생성되어 성능이 떨어지는 것은 아닌가? -> 인스턴스 캐싱을 통해 문제 해결

### 인스턴스 변수(필드) 리팩토링

원시 값을 포장하면서 인스턴스 변수의 타입이 변경되는 경우



### 데이터베이스 테이블 칼럼 변경에 따른 점진적인 리팩토링

대부분의 경우 alter table을 통해 칼럼 추가/삭제 등을 토해 해결 가능

단, 특정 칼럼의 데이터 타입을 변경, 하나의 칼럼을 2개로 분리 등등

* 1단계: alter table을 통해 리팩토링하려는 (to-be)새로운 칼럼 추가
* 2단계: 서비스 배포(as-is 칼람과 to-be칼럼 공존)
* 3단계: alter table을 통해 기존 (as-is) 칼럼 drop
* 4단계: 서비스 배포(only to-be 칼럼)

### 프레임워크 변경에 따른 리팩터링 전략

* Struts2 MVC 프레임워크 -> Spring MVC 프레임워크로 변경

<figure><img src="../../../.gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

* 기반 코드를 구현해 두 개의 프레임워크가 공존할 수 있는 환경을 구축한다.
* 두 개의 프레임워크가 공존한 상태에서 서비스를 운영하면서 점진적으로 Legacy API를 새로운 API로 변경하는 작업을 진행한다.
* Legacy 프레임워크를 사용하는 모든 코드에 대한 리팩터링을 끝내면 Legacy 프레임워크를 제거한다.



## NextStep 플랫폼 평가 기능 전환 사례를 통한 점진적인 개선

### NextStep 플랫폼 평가 기능

* 리뷰어가 리뷰이에게 피드백을 남긴다.
* 리뷰이가 리뷰어에게 피드백을 남긴다.
* 짝 프로그래밍, 팀 프로젝트를 진행한 동료에게 피드백을 남긴다.

### 플래폼 평가의 한계

* 정성 피드백을 하나 밖에 남길 수 없다.
* 정성 피드백은 마지막에 위치한다.



## 미션4. LMS 소개

응용 애플리케이션(웹, 모바일 애플리케이션)을 개발할 때 이 과정에서 배운 TDD, OOP를 적용하려면 핵심 비지니스 로직을 도메인 객체가 담당하도록 구현하는 것이다.

즉, 테스트하기 쉬운 부분과 테스트하기 어려운 부분을 분리해 테스트하기 쉬운 부분에 대한 단위 테스트를 구현하고, 지속적으로 리팩터링 한다.

### 레거시 코드 리팩터링의 1단계는

* Service Layer에 단위 테스트를 추가한 후 비지니스 로직을 도메인 객체로 이동하는 리팩터링
* Acceptance Test를 추가한 후 리팩터링

이번 클린코드 과정의 목표는 Service Layer에 단위 테스트를 추가한 후 비지니스 로직을 도메인 객체로 이동하는 리팩터링이다.



### 서비스 레이어의 역할

* 도메인 객체 로딩하는 역할
* 도메인 객체에 메시지를 보내는 역할
* 상태가 변환된 상태를 데이터베이스에 반영하는 역할

서비스 레이어가 너무 많은 역할을 하는건 아닌지 돌아보자.











## 핵심 정리

서비스 레이어의 도메인 로직을 각 도메인 객체로 옮기고 테스트 하기 쉬운코드와 어려운 코드를 분리해서 지속적으로 리팩토링하자.

















