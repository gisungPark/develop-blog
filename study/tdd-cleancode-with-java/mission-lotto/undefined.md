# 로또 피드백

## TDD, 리팩토링 연습 단계

* 학습테스트: 새로운 뭔가를 배울때, 학습 테스트를 생활화해라.
* 단위테스트: 내가 구현한 코드에 대한 단위 테스트
* TDD

하나의 미션을 반복적으로, 다른 방식으로 진행하는 것이 더 학습에 효율적이다.

스스로 문제를 설계하고, 난이도를 높일 수 있어야한다.



## 시작하기

* 요구사항 분석을 통한 기능 목록 작성
* 객체 설계를 통해 어느 부분부터 구현을 시작할 것인지 결정

tdd 내부에 리팩토링, 클래스 설계 과정이 있다해서 tdd를 시작할 때,클래스 설계과정을 안하는게 아니다. 클래스 설계과정이 선행되어야 tdd 작업이 쉬워진다.&#x20;

### 기능 목록 예시

* 구매할 로또의 매수 구하기
  * 1000 -> 1
  * 1500 -> 1
  * 500 -> error
* 한장의 로또 생성
* 당첨 번호 생성
  * 정상적인 당첨번호 입력
  * 유효하지 않은 당첨번호 입력
* 한장의 로또에 대한 당첨 결과 구하기
* n장의 로또 당첨 결과 구하기
* 로또 결과에 따른 수익률 구하기&#x20;

진행하다가 빠진 todo 리스트가 발견될 것이다.&#x20;

<mark style="background-color:yellow;">**데이터베이스와 의존관계를 맺고 있으면 테스트가 어려워진다. 때문에 테스트 힘든 부분(데이터베이스와 의존하는 부분)과 그렇지 않은 부분을 분리할 수 있는 역량을 가져야한다.**</mark>

<mark style="background-color:yellow;">**데이터베이스에 의존하지 않는 핵심 비즈니스 로직에 대한 집중적인 단위테스트를 진행한다. 이것이 이 교육과정의 1차 목표이다.**</mark>&#x20;

## TDD로 구현할 기능 찾기

* 구현 중간 부분을 자르는 연습을 해야한다.
* 즉, 프로그램이 실행되는 특정 시점의 상태 값으로 시작한다는 것을 의미한다.&#x20;

### 자동차 경주 게임 - 우승자 구하기

* 자동차 경주 게임을 완료한 시점의 자동차 상태 값을 테스트 코드에서 변경 또는 결정 할 수 있음을 의미한다.

```java
@test
public void func() {
    List<Car> cars = Arrays.asList( 
            new Car("aa", 3),
            new Car("bb", 4),
            new Car("cc", 4));
                        
        assertThat(winners).containsExactly(
                new Car("bb", 4),
                new Car("cc", 4));                                
}
```

### 로또에서 TDD로 구현할 기능 찾기

* 로또 구매 금액을 전달하면 구매할 수 있는 로또의 장수를 반환한다.
* 구매할 로또의 장 수만큼 자동 구매할 경우 자동 로또 생성해 반환한다.
* 구매한 한장의 로또 번호와 당첨 번호를 넣으면 당첨 결과를 반환한다.
* 구매한 전체 로또의 당첨 결과를 입력하면 당첨금 총액을 반환한다.
* 당참 금액과 구매 금액을 넣으면 수익률을 반환한다.

너무 큰 단위를 tdd로 진행하려하면 힘들다. 작은 단위의 input과 output를 결정해 연결하자.



## 한장의 로또에 대한 당첨 결과 구하기

오늘 강의는 객체 설계 경험이 부족한 주니어 객발자이거나,\
객체 설계가 부족한 레거시 코드가 존재하는 상황을 가정한 내용이다.

&#x20;

* match 매서드내, rank를 계산하는부분이 성격이 다른것 같아 분리하다.
* private 메서드를 테스트 해야하는가에 대한 고민이 생긴다.
  * 테스트를 위해 접근 제어자를 느슨하게 가져가는게 옳은가?
  * <mark style="background-color:yellow;">**위 내용이 고민된다면, 이 메서드가 해당 클래스에 있는게 맞는지 고민해보자.**</mark>











