# @Transactional의 이해

스프링은 @Transactional 어노테이션을 이용한 선언적 트랜잭션 처리를 지원한다.

## 트랜잭션이란?

모든 작업들이 성공적으로 완료되어야 작업 묶음의 결과를 적용하고, 어떤 작업에서 오류가 발생했을 때는 이전에 있던 모든 작업들이 성공적이었더라도 없었던 일처럼 완전히 되돌리는 것이 트랜잭션의 개념이다.

데이터베이스를 다룰 때 트랜잭션을 적용하면 데이터 추가, 갱신, 삭제 등으로 이루어진 작업을 처리하던 중 오류가 발생했을 때 모든 작업을 원상태로 되돌릴 수 있다. 모든 작업들이 성공해야만 최종적으로 데이터베이스에 반영되도록 한다.

트랜잭션은 ACID(원자성/일관성/격리성/지속성)을 보장해야한다.&#x20;

*   **원자성;**

    트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하든가 모두 실패해야 한다.&#x20;
*   **일관성;**

    모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.
*   **격리성;**

    동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 결리한다. 예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다. 격리성은 동시성과 관련된 성능 이슈로 인해 결리 수준을 선택할 수 있다.
*   **지속성;**

    트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어얗 한다. 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.&#x20;

### 트랜잭션 격리수준

트랜잭션은 원자성, 일관성, 지속성을 보장한다. 문제는 격리성인데 트랜잭션 간에 격리성을 완벽히 보장하려면 트랜잭션을 거의 차례대로 실행해야 한다. 이렇게 하면 동시성 처리 성능이 매우 나빠진다. 이런 문제로 인해 ANSI 표준은 트랜잭션의 격리 수준을 4단계로 나누어 정의했다.&#x20;

트랜잭션 격리 수준(isolation level)은 다음과 같다.

* READ UNCOMMITTED(커밋되지 않은 읽기)
* READ COMMITTED(커밋된 읽기)
* REQEATABLE READ(반복 가능한 읽기)
* SERIALIZABLE(직렬화 가능)

순서대로 READ UNCOMMITTED의 격리 수준이 가장 낮고 SERIALIZABLE의 격리 수준이 가장 높다. 격리 수준이 낮을 수록 동시성은 증가하지만 격리 수준에 따른 다양한 문제가 발생한다.&#x20;





## 스프링에서 @Transactional을 이용하여 트랜잭션 처리를 하는 방법

DB와 관련된, 트랜잭션이 필요한 서비스 클래스 혹은 메서드에 @Transactional 어노테이션을 달아주면 된다. 그러면 이 클래스에 트랜잭션 기능이 적용된 프록시 객체가 생성된다. 이 프록시 객체는 @Transactional이 포함된 메소드가 호출 될 경우, PlatformTransactionManager를 사용하여 트랜잭션을 시작하고, 정상 여부에 따라 Commit 또는 Rollback 한다.&#x20;

<mark style="color:orange;">**클래스, 메서드 모두에 @Transactional 어노테이션을 붙이면 메서드 레벨의 @Transactional 선언이 우선 적용된다.**</mark>

@Transactional이 붙은 메서드는 메서드가 포함하고 있는 작업 중에 하나라도 실패할 경우 전체 작업을 취소한다.









## 테스트 환경에서의 @Transactional 동작









## 그 외 주의사항

### 01. ID는 롤백되지 않는다.

주로 insert 작업을 할 때, id(식별자)가 자동으로 증가하도록 Auto Increment 옵션을 적용하고 하는데, 트랜잭션에 포함된 insert 작업으로 인해 증가한 id는 트랜잭션이 롤백되어도 다시 감소하지 않는다.

Auto Increment 옵션은 트랜잭션 범위 밖에서 동작하기 때문이다. 트랜잭션 범위 안에서 동작하면 같이 롤백되고 id도 순서대로 부여할 수 있기 때문에 편할 것 같은데 왜 그럴까? 바로 동시성 때문이다.

여러 사람이 동시에 한 사이트에 회원가입을 하는 상황을 생각해보자. 각각 insert 문이 포함된 트랜잭션이 진행되는데, 중복되 아이디 혹은 올바르지 않은 양식의 아이디 입력 등 여러 요인으로 인해 트랜잭션이 실패할 수 도 있고, 성공할 수도 있다.&#x20;

각 트랜잭션이 다른 사람의 회원 가입 트랜잭션 성공 여부를 기다렸다가 id를 부여받기엔 얼마다 기다려야 될 지 모르는 일이다.









## Referenc

* [https://tecoble.techcourse.co.kr/post/2021-05-25-transactional/](https://tecoble.techcourse.co.kr/post/2021-05-25-transactional/)
*









